<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <title>Module 2</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>


    <!-- Twilight forest content row (no emojis) -->
    <div class="twilight-content">
      <h1 class="twilight-title">Welcome to Steven's Twilight Forest</h1>
      <p class="twilight-intro">A moody, cinematic web experience inspired by the Pacific Northwest.</p>
    </div>
    <!--- Button for time (kept as requested) -->
    <button id="demoButton">Click Me!</button>
    <div id="messageDisplay"></div>



<script src="main.js"></script>

<!-- Contour SVG overlay for elevation lines -->
<div id="contour-container">
  <svg id="contour-svg" width="100%" height="100%" viewBox="0 0 1200 700" preserveAspectRatio="none" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:5;pointer-events:auto;">
    <!-- Contour lines will be generated by JS -->
  </svg>
</div>

<script>
// Generate contour lines as SVG paths
const svg = document.getElementById('contour-svg');
const lines = 10;
const width = 1200;
const height = 700;
const baseAmplitude = 30;
const baseFrequency = 0.012;
let waveOffsets = Array(lines).fill(0);
let waveRipples = Array(lines).fill([]).map(() => []);

  svg.innerHTML = '';
  for (let i = 0; i < lines; i++) {
    let path = '';
    let amp = baseAmplitude + i * 12;
    let freq = baseFrequency + i * 0.002;
    for (let x = 0; x <= width; x += 8) {
      let y = height/2 + (i-5)*40 + Math.sin(x * freq) * amp;
      // Sum all ripples for this line
      if (Array.isArray(waveRipples[i])) {
        for (const ripple of waveRipples[i]) {
          let dist = Math.abs(x - ripple.x);
          y += Math.sin(dist/30 - ripple.t) * Math.exp(-dist/200) * 40 * (ripple.t > 0 ? 1 : 0);
        }
      }
      path += (x === 0 ? 'M' : 'L') + x + ',' + y + ' ';
    }
    let p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d', path);
    p.setAttribute('stroke', '#fff');
    p.setAttribute('stroke-width', 2 + i*0.5);
    p.setAttribute('fill', 'none');
    p.setAttribute('opacity', 0.7 - i*0.05);
    svg.appendChild(p);
  }
}

  // Add a new ripple for each line
  let t = 0;
  for (let i = 0; i < lines; i++) {
    waveRipples[i].push({x: clickX, t: 0});
  }
  function step() {
    t += 0.06;
    for (let i = 0; i < lines; i++) {
      // Update all ripples for this line
      waveRipples[i] = waveRipples[i].filter(r => r.t < 3 * Math.PI);
      for (const ripple of waveRipples[i]) {
        ripple.t += 0.06;
      }
    }
    drawContours(waveOffsets, waveRipples);
    if (waveRipples.some(arr => arr.length > 0)) {
      requestAnimationFrame(step);
    }
  }
  step();
}

svg.addEventListener('click', function(e) {
  // Get click x in SVG coordinates
  const rect = svg.getBoundingClientRect();
  const x = ((e.clientX - rect.left) / rect.width) * width;
  animateRipple(x);
});

drawContours();
</script>
</body>
</html>

